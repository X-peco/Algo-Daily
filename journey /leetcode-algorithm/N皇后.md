# [51. N 皇后](https://leetcode.cn/problems/n-queens/)

# 📋 题目描述
> **给定一个N×N的矩阵，如何摆放n个皇后棋子，皇后的攻击范围是：以皇后为起原点的行，列，左斜线，右斜线。要求每个皇后的攻击范围内不可以放置其余皇后**

---

# 💡 解题思路

## 基础思路
**首先想法当然是dps，维护一个状态检测行，列，斜线是否为非"False"。然后对矩阵每个点进行遍历，调用dps，用个列表存储dps中皇后下标坐标，最终若符合n个数量，则添加进最终解答方案中**

#### 🔍 优化发现
**然后就注意到首先可以改善的方法，由于是n×n矩阵，每个皇后所在行没有别的，又要放置n个皇后，所以可以得出每个行都有且只有一个皇后，故此我们可以不需要遍历每个点，只要遍历每行，同时省去了对行状态的维护**

**往常寻常的dps检测访问过的地域，需要保存路过的点的下标地址，这样的话，去表示列还是寻常操作，那如何表示斜线呢？**

从行的任意点出发的斜线，所经过的点，似乎这样就不好表示了，那思考一下，我们首先有对行遍历，同时对列遍历的操作，自然有获得两个下标，也是相应坐标：
```python
# 伪代码大概操作
for row in range(len(grid)):
    for col in range(len(grid[0]))
```
**斜线的话，这里很显然用数学表示就是斜率为±1，即可以翻译出 row=±col+b，每个点从斜线出发，row±col可以得出固定的b1和b2，我们就可以思考一下，每个点，如果放置皇后，那所产生的斜线每条都是不同的，所以用row±col的值，反映的左右斜向的直线是唯一的，dps时检测访问与否，我们是不是就可以通过比较row±col的值来反映每个皇后产生的不可访问的斜线，而不需要记录每个点的状态就可以确认是否访问过**

​​***至此我们优化了标记走过的路的，检测条件，ow±col的值，作为key，对应唯一的斜线。接下来的操作就是基本的dps操作了***

## 📝 代码实现
```python
class Solution(object):
    def solveNQueens(self, n):
        """
        :type n: int
        :rtype: List[List[str]]
        """
        # 列占用状态
        cols_status = [False] * n
        
        # 对角线状态（左斜线：row - col；右斜线：row + col）
        diag1 = set()
        diag2 = set()

        # 存储当前解的列位置
        ans = []
        # 存储所有有效解
        final = []

        def dfs(row):
            # 所有行都放置了皇后，找到一个有效解
            if row == n:
                final.append(list(ans))
                return

            # 尝试在当前行的每一列放置皇后
            for col in range(n):
                # 检查是否冲突
                if cols_status[col] or (row - col) in diag1 or (row + col) in diag2:
                    continue

                # 放置皇后，更新状态
                cols_status[col] = True
                diag1.add(row - col)
                diag2.add(row + col)
                ans.append(col)  # 记录当前皇后位置
                
                # 继续放置下一行
                dfs(row + 1)
                
                # 回溯，撤销当前选择
                ans.pop()
                cols_status[col] = False
                diag1.remove(row - col)
                diag2.remove(row + col)

        # 从第0行开始搜索
        dfs(0)

        # 格式转换：将解转换为棋盘表示
        result = []
        for sol in final:
            board = []
            for col in sol:  # sol中存储每一行皇后的列位置
                row_chars = ['.'] * n
                row_chars[col] = 'Q'
                board.append(''.join(row_chars))
            result.append(board)
            
        return result
```


### 回溯流程
```text
+-------------------------------------+
|       选择当前行有效列位置           |
+------------------+------------------+
                   |
                   v
+-------------------------------------+
| 更新状态：                          |
|   - 标记列占用                       |
|   - 添加左斜线标识(row-col)          |
|   - 添加右斜线标识(row+col)          |
+------------------+------------------+
                   |
                   v
+-------------------------------------+
|       递归处理下一行                |
+------------------+------------------+
                   |
                   v
+-------------------------------------+
|      所有行处理完成？               |
|          +------------+             |
|          |            |             |
|       是 |            | 否          |
|          |            |             |
|          v            v             |
| +----------------+ +----------------+
| | 保存有效解     | | 回溯恢复状态     |
| +----------------+ +----------------+
|                                |
|                                v
|                      +----------------+
|                      | 继续搜索其他位置 |
|                      +----------------+
```

### 复杂度分析
* 时间复杂度：O(N!)
* 实际由于剪枝操作，效率优于阶乘复杂度

### 空间复杂度：O(N)
* 用于存储列状态和斜线集合，递归栈深度为 O(N)

### 算法优势
状态表示高效
* 列：布尔数组直接标记
* 斜线：数学关系转换实现常数时间检测
  
剪枝优化
* 冲突检测提前终止无效路径
* 避免不必要的递归调用
  
结果转换简洁
* 仅需存储列位置即可重建完整棋盘
* O(N²) 时间内完成所有解转换

