# [ ğŸš¦ å•è¯æ¥é¾™ï¼ˆWord Ladder IIï¼‰](https://leetcode.cn/problems/word-ladder-ii)

# é¢˜ç›®æè¿°

>***ç»™ä½ ä¸¤ä¸ªå•è¯ï¼Œä¸€ä¸ªå•è¯ä½œä¸ºèµ·å§‹å•è¯ï¼Œä¸€ä¸ªå•è¯ä¸ºç»ˆç‚¹å•è¯ï¼Œè¦æ±‚ä½ ä»èµ·å§‹å•è¯å¼€å§‹ï¼Œæ¯æ¬¡ä¿®æ”¹ä¸€ä¸ªå­—ç¬¦ï¼Œæœ€å°‘éœ€è¦ç»å†å‡ ä¸ªä¸­é—´æ€
>åŒæ—¶ç»™å®šä¸€ä¸ªä¸­é—´æ€å•è¯åˆ—è¡¨ï¼Œè¦æ±‚ä¿®æ”¹è¿‡ç¨‹äº§ç”Ÿçš„ä¸­é—´æ€å•è¯ï¼Œå‡ºç°åœ¨è¿™ä¸ªå•è¯åˆ—è¡¨ä¸­***


## ç¤ºä¾‹è¾“å‡º

>**è¾“å…¥ï¼šbeginWord = "hit", endWord = "cog", wordList =\["hot","dot","dog","lot","log","cog"]**
>
  **è¾“å‡ºï¼š\[\["hit","hot","dot","dog","cog"],\["hit","hot","lot","log","cog"]]**
  
>**è§£é‡Šï¼šå­˜åœ¨ 2 ç§æœ€çŸ­çš„è½¬æ¢åºåˆ—ï¼š**
*"hit" -> "hot" -> "dot" -> "dog" -> "cog"
"hit" -> "hot" -> "lot" -> "log" -> "cog"*

---
# æ€è·¯

**é¢˜ç›®è¦æ±‚æ¯æ¬¡åªèƒ½ä¿®æ”¹ä¸€ä¸ªå­—ç¬¦ï¼ŒåŒæ—¶è¿™ä¸ªå­—ç¬¦è¿˜éœ€è¦å­˜åœ¨äºä¸­é—´æ€åˆ—è¡¨ä¸­**

**æˆ‘ä»¬å…ˆæƒ³æƒ³ï¼Œå…¶ä¸­ä¸€ä¸ªç»“æœï¼Œå®ƒçš„*ç»“æ„ç‰¹å¾*å¤§è‡´æ˜¯æ€ä¹ˆæ ·çš„ï¼Œå°±ç»™å‡ºçš„è¾“å‡ºç¤ºä¾‹æ¥çœ‹\["hit","hot","lot","log","cog"]ï¼Œæ¯ä¸ªç›¸é‚»å•è¯çš„å·®å¼‚ä¸ºä¸€ä¸ªå­—ç¬¦çš„ä¸åŒï¼Œè¿›ä¸€æ­¥æƒ³è±¡ï¼Œæ¯ä¸ªå•è¯è§†ä¸ºä¸€ä¸ª*èŠ‚ç‚¹*ï¼Œèƒ½ä¸è¿™ä¸ªèŠ‚ç‚¹ç›¸è¿çš„è¦æ±‚æ˜¯ï¼Œåªæœ‰*ä¸€ä¸ªå­—ç¬¦å·®å¼‚*ï¼Œå°±è¿™ä¹ˆè¿è¿è¿ï¼Œç›´åˆ°é‡åˆ°endWordæˆªæ­¢**

**äºæ˜¯æˆ‘ä»¬å°±éœ€è¦ï¼ŒæŸ¥æ‰¾ä»beginWordå¼€å§‹ï¼Œç›¸é‚»çš„ï¼Œä¸”å­˜åœ¨äº*ä¸­é—´æ€å•è¯é›†*çš„ï¼Œ*ç›¸é‚»å•è¯é›†*ã€‚å†å¯¹ç›¸é‚»å•è¯é›†çš„å•è¯é‡å¤åŒæ ·æ“ä½œï¼Œç»™å…¶ä¸­çš„å•è¯æœé›†å‡ºï¼Œç›¸é‚»çš„ï¼Œä¸”å­˜åœ¨äº*ä¸­é—´æ€å•è¯é›†*çš„ï¼Œ*ç›¸é‚»å•è¯é›†*ã€‚**

 **æˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—Aå’Œä¸€ä¸ªé›†åˆã€‚è¿™ä¸ªAä¸€å¼€å§‹åªå­˜å‚¨å•è¯(begin Word)ï¼Œé›†åˆç”¨æ¥o(1)å¤æ‚åº¦æŸ¥æ‰¾ï¼Œå‚¨å­˜çš„æ˜¯*ä¸­é—´æ€åˆ—è¡¨çš„å€¼*ï¼Œæˆ‘ä»¬è¿˜æ˜¯é‡‡å–BFSçš„ç­–ç•¥ï¼Œ** ***éå†é˜Ÿåˆ—ï¼ŒæŸ¥æ‰¾ç›¸é‚»***ï¼Œ**æ¥ä¸‹æ¥æˆ‘ä»¬çš„æ“ä½œéœ€è¦åšå‡ºä¸¤ä¸ªè¡Œä¸ºï¼ŒBFSçš„åŒæ—¶å‚¨å­˜æ¯ä¸ªä¸­é—´æ€å•è¯çš„ç›¸é‚»å•è¯ï¼Œä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬å…ˆåˆ›å»ºä¸€ä¸ªç©ºé˜Ÿåˆ—Bï¼Œä»beginWordå¼€å§‹ï¼Œå…ˆåˆ›é€ å®ƒæ‰€æœ‰çš„ç›¸é‚»å•è¯ï¼ŒåŒæ—¶åŒ¹é…æ‰¾åˆ°å‡ºç°åœ¨*ä¸­é—´æ€å•è¯åˆ—è¡¨*ä¸­çš„é‚£äº›ï¼ŒæŠŠè¿™äº›å•è¯åŠ å…¥beginWordçš„ç›¸é‚»é›†ï¼ŒåŒæ—¶è¿™äº›å•è¯åŠ å…¥Bï¼Œç”±äºç°åœ¨åªæœ‰ä¸€ä¸ªå•è¯ï¼Œæ‰€ä»¥ï¼Œè¿›è¡Œçš„æ“ä½œåªæœ‰ï¼Œç»™è¿™ä¸€ä¸ªå•è¯æŸ¥æ‰¾*ç›¸é‚»å•è¯*ï¼Œå¹¶ä¸”Bæ·»åŠ çš„åªæœ‰è¿™ä¸ªå•è¯çš„ç›¸é‚»å•è¯ï¼Œç„¶åå°†Aæ›´æ–°ä¸ºBï¼ŒåŒæ—¶å°†*ä¸­é—´æ€å•è¯é›†*çš„ä¸­çš„Bå…¨éƒ¨åˆ é™¤ï¼Œé¿å…ä¸‹ä¸€å±‚æŸ¥æ‰¾æ—¶å€™æŸ¥æ‰¾å½“å‰å•è¯ï¼Œæˆ‘è§£é‡Šè¿™ä¸ªè¡Œä¸ºä¸ºï¼ˆå€’æµï¼‰**



  # BFS/ç›¸é‚»å•è¯é›†

<details>
  <summary><strong>Python ä»£ç </strong></summary>

```python
while q1 and not found:
    # æ–°çš„å±‚
    q = set()
    # éå†å½“å‰é˜Ÿåˆ—æ‰€æœ‰å•è¯
    for word in q1:
        for tar_index in range(len(word)):
            for ex in alpha:
                # èŠ‚çœé‡å¤çš„å°æŠ€å·§
                if word[tar_index] == ex:
                    continue
                next_word = word[:tar_index] + ex + word[tar_index+1:]
                if next_word in q2:
                    found = True
                    next_words[word].append(next_word)
                if not found and next_word in dic_words:
                    next_words[word].append(next_word)
                    q.add(next_word)
    # æœ¬å±‚ç»“æŸï¼Œåˆ æ‰å·²è®¿é—®çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢å€’æµ
    dic_words -= q
```
</details>


<details>
  <summary><strong>C++ ä»£ç </strong></summary>

```cpp
void bfsWordLadder(
    unordered_set<string>& q1,
    unordered_set<string>& q2,
    unordered_set<string>& dic_words,
    unordered_map<string, vector<string>>& next_words,
    const string& alpha,
    bool& found
) {
    while (!q1.empty() && !found) {
        unordered_set<string> q;
        for (const string& word : q1) {
            for (size_t tar_index = 0; tar_index < word.size(); ++tar_index) {
                for (char ex : alpha) {
                    if (word[tar_index] == ex) continue;
                    string next_word = word.substr(0, tar_index) + ex + word.substr(tar_index + 1);
                    if (q2.find(next_word) != q2.end()) {
                        found = true;
                        next_words[word].push_back(next_word);
                    }
                    if (!found && dic_words.find(next_word) != dic_words.end()) {
                        next_words[word].push_back(next_word);
                        q.insert(next_word);
                    }
                }
            }
        }
        for (const string& w : q) dic_words.erase(w);
        q1 = std::move(q);
    }
}
```
</details>

---

## ä¼˜åŒ–

**ç»“åˆè¿™é‡ŒBFSï¼Œé€å±‚éå†ï¼ŒæŸ¥æ‰¾ç›¸é‚»ï¼Œçš„æ€§è´¨ï¼Œè§‚å¯Ÿåˆ°ä¸€ä¸ªç°è±¡ï¼Œä»beginWordå¼€å§‹ï¼Œå‡è®¾æ¯æ¬¡æœ‰æ•ˆç›¸é‚»å•è¯ä¸ºnä¸ªï¼Œé˜Ÿåˆ—æ¼”åŒ–ï¼š1->n->n*n->n*n*n->...æ·±åº¦mä¸ºbeginWordé•¿åº¦(é»˜è®¤beginWordå’ŒendWordé•¿åº¦ä¸€æ ·)ï¼Œå¯è§è¿™ä¸ªæŒ‡æ•°å˜åŒ–éšç€BFSæ·±åº¦ï¼Œä¼šé€ æˆå¤§å¹…çš„æ€§èƒ½ä¸‹æ»‘ï¼Œæˆ‘ä»¬åŸæ¥çš„æ–¹å¼æ˜¯ä»beginWordå¼€å§‹çš„é˜Ÿåˆ—Aï¼Œé‚£æˆ‘ä»¬å¢åŠ ä¸€ä¸ªä»endWordå¼€å§‹çš„é€†å‘çš„é˜Ÿåˆ—Cï¼Œå¦‚æœé˜Ÿåˆ—Bä¸­çš„å•è¯çš„ç›¸é‚»å•è¯å‡ºç°åœ¨Cä¸­ï¼Œåˆ™å®Œæˆäº†èŠ‚ç‚¹çš„ç›¸è¿ï¼Œå®ç°äº†ä¸€ä¸ªå®Œæ•´çš„è·¯å¾„ï¼Œæ¯æ¬¡è·Ÿæ–°Bï¼Œç”¨æœ€çŸ­(å•è¯æ•°é‡æœ€å°‘)çš„é˜Ÿåˆ—(A/C)è·Ÿæ–°ï¼Œå°½å¯èƒ½å‡å°‘æŒ‡æ•°çš„å·¨é¢æŒ‡æ•°å¢åŠ **

<details>
  <summary><strong>å¯¹å˜é‡reversed_flagçš„æç¤º</strong></summary>

**reversed_flag ç”¨æ¥æ£€æµ‹æ˜¯ä»å¤´æ¥è¿˜æ˜¯ä»å°¾å·´æ¥ï¼Œä»¥ä¾¿æ¸…æ¥šï¼Œå¯¹å•è¯æ·»åŠ ç›¸é‚»å•è¯çš„é€»è¾‘**

</details>



<details>
  <summary><strong>Python ä»£ç </strong></summary>

```python
while q1 and not found:
    q = set()
    for word in q1:
        s = list(word)
        for i in range(len(s)):
            origin = s[i]
            for c in 'abcdefghijklmnopqrstuvwxyz':
                s[i] = c
                new_word = ''.join(s)
                if new_word in q2:
                    # è‹¥åœ¨å¦ä¸€ç«¯é›†åˆä¸­ï¼Œè¯´æ˜æ‰¾åˆ°äº†è¿æ¥ç‚¹
                    if reversed_flag:
                        next_map[new_word].append(word)
                    else:
                        next_map[word].append(new_word)
                    found = True
                if not found and new_word in dict_set:
                    if reversed_flag:
                        next_map[new_word].append(word)
                    else:
                        next_map[word].append(new_word)
                    q.add(new_word)
            s[i] = origin
    dict_set -= q
    # ä¼˜å…ˆæ‰©å±•èŠ‚ç‚¹è¾ƒå°‘çš„ä¸€ç«¯
    if len(q) < len(q2):
        q1 = q
    else:
        reversed_flag = not reversed_flag
        q1, q2 = q2, q
```
</details>



<details>
  <summary><strong>C++ ä»£ç </strong></summary>

```cpp
while (!q1.empty() && !found) {
    // æ–°ä¸€å±‚
    std::unordered_set<std::string> q;
    // éå†å½“å‰å±‚çš„æ‰€æœ‰èŠ‚ç‚¹
    for (const auto& word : q1) {
        std::string s = word;
        for (size_t i = 0; i < s.size(); ++i) {
            char origin = s[i];
            for (char c = 'a'; c <= 'z'; ++c) {
                s[i] = c;
                std::string new_word = s;
                if (q2.find(new_word) != q2.end()) {
                    // è‹¥åœ¨å¦ä¸€ç«¯é›†åˆä¸­ï¼Œè¯´æ˜æ‰¾åˆ°äº†è¿æ¥ç‚¹
                    if (reversed_flag) {
                        next_map[new_word].push_back(word);
                    } else {
                        next_map[word].push_back(new_word);
                    }
                    found = true;
                }
                if (!found && dict_set.find(new_word) != dict_set.end()) {
                    if (reversed_flag) {
                        next_map[new_word].push_back(word);
                    } else {
                        next_map[word].push_back(new_word);
                    }
                    q.insert(new_word);
                }
            }
            s[i] = origin;
        }
    }
    // æœ¬å±‚ç»“æŸï¼Œåˆ æ‰å·²è®¿é—®çš„èŠ‚ç‚¹ï¼Œé˜²æ­¢ç¯
    for (const auto& w : q) dict_set.erase(w);
    // ä¼˜å…ˆæ‰©å±•èŠ‚ç‚¹è¾ƒå°‘çš„ä¸€ç«¯
    if (q.size() < q2.size()) {
        q1 = q;
    } else {
        reversed_flag = !reversed_flag;
        std::swap(q1, q2);
        q1 = q;
    }
}
```
</details>

---

***è‡³æ­¤æˆ‘ä»¬é€šè¿‡BFSï¼Œæ‰¾å‡ºäº†beginWordçš„ç›¸é‚»å•è¯ï¼Œä»¥åŠç”±æ­¤è¡ç”Ÿå‡ºï¼Œç›¸é‚»å•è¯çš„ç›¸é‚»å•è¯(ä¼¼ä¹æœ‰ç‚¹ç»•ï¼Œå…¶å®ç†è§£äº†çš„è¯ï¼Œè¿˜è›®å¥½ç†è§£çš„ï¼Ÿï¼Ÿ)ï¼Œäºæ˜¯å·®ä¸€ä¸ªç›¸å¯¹è½»æ¾ä¸€ç‚¹çš„é€’å½’+å›æº¯å‡ºç­”æ¡ˆäº†ï¼Œé€’å½’æ¯ä¸ªå•è¯çš„å•è¯é›†ï¼ŒåŒæ—¶æ³¨æ„å›æº¯çš„è®¾ç½®***

<details>
  <summary><strong>Python ä»£ç </strong></summary>

```python
if found:
    path = [beginWord]
    def backtracking(src: str):
        if src == endWord:
            ans.append(list(path))
            return
        for nxt in next_map[src]:
            path.append(nxt)
            backtracking(nxt)
            path.pop()
    backtracking(beginWord)
return ans
```
</details>



<details>
  <summary><strong>C++ ä»£ç </strong></summary>

```cpp
if (found) {
    std::vector<std::string> path{beginWord};
    std::vector<std::vector<std::string>> ans;
    std::function<void(const std::string&)> backtracking = [&](const std::string& src) {
        if (src == endWord) {
            ans.push_back(path);
            return;
        }
        for (const auto& nxt : next_map[src]) {
            path.push_back(nxt);
            backtracking(nxt);
            path.pop_back();
        }
    };
    backtracking(beginWord);
    return ans;
}
```
</details>

---

# æ—¶é—´å¤æ‚åº¦

* *è¿™ä¸€é¢˜å°±æ¯”è¾ƒå¤æ‚äº†åˆ†æï¼Œä½†å‰é¢ä¹Ÿç¨å¾®æ¶‰åŠäº†ä¸€ç‚¹â€œé˜Ÿåˆ—æ¼”åŒ–ï¼š1->n->n*n->n*n*n->...*æ·±åº¦mä¸ºbeginWordé•¿åº¦(é»˜è®¤beginWordå’ŒendWordé•¿åº¦ä¸€æ ·)â€ï¼Œnä¸ºå‡è®¾å€¼ï¼Œå‡è®¾æ¯æ¬¡æœ‰æ•ˆç›¸é‚»æ˜¯nä¸ªï¼Œå§‘ä¸”è¯´æ˜¯nçš„mæ¬¡æ–¹å§ï¼Œæ—¶é—´å¤æ‚åº¦*

---
